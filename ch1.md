# 关于对象 Object Lessons

## 加上封装后的布局成本 Layout Costs for Adding Encapsulation

`Zero-cost abstraction`最关键的地方是`Don't pay for things you don't use`。它在于可以为你提供代码的抽象，而不加额外的负担。

`C++`被称为`Zero-cost abstraction`，某种程度上，这代表着你可以定义`class`，也可以把`class`转化分离为你熟悉的`struct`与一系列算法。而定义`class`这样的抽象，与你手动这样写相比，并非增加额外的精力与开销：

```cpp
struct Point3D {
  float x;
  float y;
  float z;
}

float x, y, z;
```

当然`Point3D`是一个`POD(Plain Old Data)`。实际实现上更多是包含继承，甚至泛型等，但这些也并不增加运行时成本。

真正增加空间和时间等成本的是由`virtual`引起的：

- `Virtual function`：虚函数，支持高效的运行期多态。
- `Virtual base class`：虚继承。例如被菱形方式继承的`base class`。

## C++ 对象模型 The C++ Object Model

对于存在虚函数的类，一定会产生一个虚函数表。这个虚函数表是属于类的，一个类只有一个虚函数表。类实例化对象中有一个指针指向这个虚函数表。

只要基类有虚函数，派生类不论实现或没实现，都有一个虚函数表。**基类的虚函数表和子类的虚函数表不是同一个表**。虚函数表是在编译时确定的，属于类而不属于某个类的实例。

如果`Class B`继承了`Class A`，其虚函数表是在`Class A`虚函数表的基础上有所改动的，变化的仅仅是在子类中重写的虚函数。如果子类没有重写任何虚函数，那么子类的虚函数表和父类的虚函数表在**内容上是一致的**。因此之所以实现了多态完全是因为**子类的虚函数指针与虚函数表的内容与基类不同**。

**虚函数指针的位置不是由C++标准规定的，而是由编译器决定的**。不同编译器可能采用不同的方式组织对象的内存布局，因此虚函数指针的具体位置可能有所不同。

### 多重继承

在多重继承的情况下，有多少个基类就有多少个虚函数表指针，前提是基类要有虚函数才算上这个类。

- 子类虚函数会覆盖**每一个**父类的**每一个**同名虚函数。
- 父类中没有的虚函数而子类有，填入第一个虚函数表中（即子类与第一个基类内容相同的虚函数表），且用父类指针是不能调用。
- 父类中有的虚函数而子类没有，则不覆盖。仅子类和该父类指针能调用。

### 多态和缺省参数

多态和缺省参数是不同的。多态是运行时动态绑定，而缺省参数是编译时静态绑定。因此，**绝不重定义继承而来的缺省参数值！**

## 关键词所带来的差异 A Keyword Distinction

什么时候该使用`struct`替换`class`？当更能明确表示类型含义的时候。例如单纯表示数据集合体，没有`private data`，也没有`member function`的时候；或者只是想利用`struct`默认的`public`接口声明（或者说主张使用`struct`表示类中成员变量和成员函数都是`public`的）。

## 对象的差异 An Object Distinction

一个指针或者引用之所以支持多态，是因为它们并不引发内存中任**与类型有关的内存委托操作**，会受到改变的，只有它们所指向的内存的**大小和内存解释方式**而已。

当一个`base class object`被直接初始化为一个`derived class object`时，`derived object`就会被切割以塞入较小的`base type`内存中，`derived type`将没有留下任何痕迹。多态于是不再呈现。
